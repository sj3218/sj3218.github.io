---
layout: page
name: Liquid Monsters
tools: [Game, Puzzle, 2D, Custom Engine]
image: "/assets/images/background/liquid.JPG"
---

# Liquid Monsters
<br>
{% include elements/video.html id="NQsKBhQuyy4" %}

<br>

<div style="display: flex; gap: 20px;">
  <div style="background-color: #2c2c2c; padding: 20px; border-radius: 8px; color: white; width: 50%;">
    <h2>Description</h2><br>
    <p>
      Liquid MonsterëŠ” 2D í”Œë«í¼ í¼ì¦ ê²Œì„ì…ë‹ˆë‹¤. ë‘ëª…ì˜ í”Œë ˆì´ì–´ê°€ ì„œë¡œë¥¼ ë¨¹ì–´ì„œ í•©ì³ì§€ê±°ë‚˜ ì•„ì´í…œì„ ì‚¬ìš©í•´ì„œ ë§µì„ í’€ì–´ë‚˜ê°€ëŠ” ê²Œì„ì…ë‹ˆë‹¤.
    </p>
    <p>
      ì €ëŠ” ê²Œì„ì— í•„ìš”í•œ ì•„ì´í…œë“¤ì„ êµ¬í˜„í•˜ê³  ImGuië¥¼ ì‚¬ìš©í•´ ì§ê´€ì ì¸ ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí•˜ì—¬ ë””ìì´ë„ˆë“¤ì´ ë§µ ë‚´ì˜ ìš”ì†Œë“¤ì„ ë°°ì¹˜í•˜ê³  ìˆ˜ì •í•  ìˆ˜ ìˆë„ë¡ í–ˆìŠµë‹ˆë‹¤. ì´ ì™¸ì—ë„ FMODë¥¼ ì´ìš©í•´ ê²Œì„ì— ì ìš©ë  ì†Œë¦¬ë“¤ì„ ì¶”ê°€í•˜ë©° ê²Œì„ì˜ ëª°ì…ê°ì„ ë†’ì´ëŠ” ë° ê¸°ì—¬í–ˆìŠµë‹ˆë‹¤.
    </p>
  </div>
  <div style="background-color: #2c2c2c; padding: 20px; border-radius: 8px; color: white; width: 50%;">
    <h2>Project Info</h2><br>
    <p>ğŸ‘¨â€ğŸ’» ì§ì±…: í”Œë ˆì´ì–´ í”„ë¡œê·¸ë˜ë¨¸, íˆ´ í”„ë¡œê·¸ë˜ë¨¸</p>
    <p>ğŸ‘¥ íŒ€ ê·œëª¨: 5</p>
    <p>â³ ê°œë°œ ê¸°ê°„: 2019.09 ~ 2020.04</p>
    <p>ğŸ› ï¸ Engine: ìì²´ ì—”ì§„(C++, OpenGL, SDL, FMOD, ImGui, Json)</p>
    <p>âš™ï¸ Files ë‹¤ìš´ë¡œë“œ: <button onclick="window.location.href='https://drive.google.com/drive/folders/1FvbOxOAOjqXc18tQbx7TBOif98px2w7J';">ì†ŒìŠ¤íŒŒì¼ ë‹¤ìš´ë¡œë“œ</button></p>
  </div>
</div>

<br>

### ì•„ì´í…œ êµ¬í˜„

###### ê²Œì„ ë‚´ì—ì„œ í”Œë ˆì´ì–´ê°€ í™œìš©í•  ìˆ˜ ìˆëŠ” ë‹¤ì–‘í•œ ì•„ì´í…œì„ êµ¬í˜„í–ˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, ë°°í„°ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¬´ë¹™ ë°•ìŠ¤ë¥¼ ì´ë™ì‹œí‚¤ê±°ë‚˜, ë²„íŠ¼ì„ ëˆŒëŸ¬ í”Œë ˆì´ì–´ë¥¼ ë„ìš°ëŠ” íŒ¬ì„ ì‘ë™ì‹œí‚¤ëŠ” ë“±ì˜ ì•„ì´í…œë“¤ì„ êµ¬í˜„í•˜ì˜€ìŠµë‹ˆë‹¤. ì•„ì´í…œ êµ¬í˜„ì—ëŠ” Component í´ë˜ìŠ¤ë¥¼ ê¸°ë°˜ìœ¼ë¡œ í•˜ì—¬ ê° ì•„ì´í…œì˜ ê¸°ëŠ¥ì„ ì •ì˜í–ˆìœ¼ë©° ì•„ì´í…œì´ ì‘ë™í•  ë•Œë§ˆë‹¤ ê·¸ë˜í”½ìŠ¤ íƒ€ì¼ë“¤ì„ ì—…ë°ì´íŠ¸í•˜ì—¬ ì‚¬ìš©ìë“¤ì´ ë³€í™”ëœ ìƒíƒœë¥¼ í™•ì¸ í•  ìˆ˜ ìˆë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤.

<details>
<summary>Battery.cpp</summary>
<div markdown="1">

```c++
Battery::Battery() : Component(eComponentType::BATTERY)
{
}

Battery::Battery(Object* batteryHome, Object* connectingObject) : Component(eComponentType::BATTERY)
{
    mObjectBatteryHome = batteryHome;
    mObjectConnecting = connectingObject;
}

void Battery::Initialize(Object* object)
{
}

void Battery::Update(float dt)
{
    mWasBatteryInHome = mIsBatteryInHome;
    

    if (mObjectConnecting != nullptr && mObjectBatteryHome != nullptr)
    {
        // in case if there is battery in battery home
        if (mIsBatteryInHome == true)
        {
            UpdateWireGraphics(mIsBatteryInHome);
            mObjectBatteryHome->GetSprite()->LoadTextureFromData(eTexture::BATTERY_HOME);

            if (mOwner->GetVelocity().x != 0.f || mOwner->GetTransform()->GetParentTransform() != nullptr)
            {
                mIsBatteryInHome = false;
                mOwner->GetSprite()->SetVisible();
            }
        }
        // if there is no battery
        else
        {
            UpdateWireGraphics(mIsBatteryInHome);
            mObjectBatteryHome->GetSprite()->LoadTextureFromData(eTexture::OBJECT_BATTERY_HOME_OFF);

            if (std::abs(mOwner->GetPosition().y - mObjectBatteryHome->GetPosition().y) < mRange)
            {
                if (std::abs(mOwner->GetPosition().x - mObjectBatteryHome->GetPosition().x) < mRange)
                {
                    if (mOwner->GetVelocity().x >= 0.f && mOwner->GetPosition().x < mObjectBatteryHome->GetPosition().x)
                    {
                        mIsBatteryInHome = true;
                        mOwner->GetSprite()->SetInVisible();
                        mOwner->SetVelocity({ 0.f, 0.f });
                    }
                    else if (mOwner->GetVelocity().x <= 0.f && mOwner->GetPosition().x > mObjectBatteryHome->GetPosition().x)
                    {
                        mIsBatteryInHome = true;
                        mOwner->GetSprite()->SetInVisible();
                        mOwner->SetVelocity({ 0.f, 0.f });
                    }
                }
            }
        }
    }

    if (mWasBatteryInHome != mIsBatteryInHome)
    {
        if (mIsBatteryInHome)
        {
            FMOD_MANAGER->PlaySoundEffectSound("sound/sfx_battery_in.mp3");

            switch (mObjectConnecting->GetObjectType())
            {
            case eObjectType::FAN:
                mObjectConnecting->GetComponentByType<Fan>(eComponentType::FAN)->SetIsFanActive(true);
                break;
            case eObjectType::MOVING_PLATFORM:
                mObjectConnecting->GetComponentByType<MovingPlatform>(eComponentType::MOVINGPLATFORM)->SetIsMovingPlatformActive(true);
                break;
            case eObjectType::PRESSURE:
                mObjectConnecting->GetComponentByType<Pressure>(eComponentType::PRESSURE)->SetIsPressureActive(true);
                break;
            }
        }
        else
        {
            switch (mObjectConnecting->GetObjectType())
            {
            case eObjectType::FAN:
                mObjectConnecting->GetComponentByType<Fan>(eComponentType::FAN)->SetIsFanActive(false);
                break;
            case eObjectType::MOVING_PLATFORM:
                mObjectConnecting->GetComponentByType<MovingPlatform>(eComponentType::MOVINGPLATFORM)->SetIsMovingPlatformActive(false);
                break;
            case eObjectType::PRESSURE:
                mObjectConnecting->GetComponentByType<Pressure>(eComponentType::PRESSURE)->SetIsPressureActive(false);
                break;
            }
        }
    }
}

void Battery::Delete(void)
{
}

void Battery::SetBattery(bool battery)
{
    mIsBatteryInHome = battery;
}

bool Battery::GetBattery(void)
{
    return mIsBatteryInHome;
}

void Battery::SetBatteryHome(Object* batteryHome)
{
    mObjectBatteryHome = batteryHome;
}

void Battery::SetConnectingObject(Object* connectingObject)
{
    mObjectConnecting = connectingObject;
}

Object* Battery::GetBatteryHome(void)
{
    return mObjectBatteryHome;
}

Object* Battery::GetConnectingObject(void)
{
    return mObjectConnecting;
}

void Battery::InsertGraphicsTile(int grid, eTexture texture)
{
    mWireTiles.insert({ grid, texture });
    TILE_MAP->FindGraphicsTileByGrid(grid)->SetTileConnectedObjectName(mOwner->GetName());
}

void Battery::EraseGraphicsTile(int grid)
{
    mWireTiles.erase(grid);
}
```
</div>
</details> 
<br>

### íˆ´ ì—ë””í„° êµ¬í˜„

{% include elements/video.html id="_AvoJwB_uuQ" %}

###### Debugging ëª¨ë“œ ì˜ìƒ
<br>

###### ë””ìì´ë„ˆë“¤ì´ ìš”ì²­í•˜ëŠ” ì‚¬í•­ì— ë”°ë¼ ì—ë””í„° íˆ´ì„ ì„¤ê³„í•˜ê³  êµ¬í˜„í–ˆìŠµë‹ˆë‹¤. **Level Editor** ë¶€ë¶„ì€ ì˜¤ë¸Œì íŠ¸ë“¤ì„ ìƒì„±í•˜ê±°ë‚˜ ì‚­ì œë¥¼ í•  ìˆ˜ ìˆë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤. ìƒì„±ëœ ì˜¤ë¸Œì íŠ¸ë“¤ì€ ë§ˆìš°ìŠ¤ë¥¼ í†µí•´ ë§µì— ì›í•˜ëŠ” ìœ„ì¹˜ì— ì´ë™ ì‹œí‚¬ ìˆ˜ ìˆê³  í…ìŠ¤ì²˜ì™€ ì• ë‹ˆë©”ì´ì…˜ì„ ì ìš©í•  ìˆ˜ ìˆë„ë¡ í•˜ì˜€ìŠµë‹ˆë‹¤. **Tile Editor**ì—ì„œëŠ” ê·¸ë˜í”½ìŠ¤ íƒ€ì¼ê³¼ ë¬¼ë¦¬ íƒ€ì¼ì„ ë§ˆìš°ìŠ¤ë¡œ ë“œë˜ê·¸ í•˜ì—¬ ë§µì„ ë””ìì¸ í•  ìˆ˜ ìˆë„ë¡ í•˜ì˜€ê³  í°ìƒ‰ìœ¼ë¡œ í…Œë‘ë¦¬ë¡œ í‘œì‹œëœ íƒ€ì¼ì€ ë¬¼ë¦¬ íƒ€ì¼ë¡œ í”Œë ˆì´ì–´ê°€ ì˜¬ë¼ ê°ˆ ìˆ˜ ìˆëŠ” íƒ€ì¼ì…ë‹ˆë‹¤. **Player Information**ì—ì„œëŠ” í”Œë ˆì´ì–´ì˜ ìœ„ì¹˜ë‚˜ ì†ë„ë¥¼ ë³¼ ìˆ˜ ìˆë„ë¡ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì œê³µí–ˆìŠµë‹ˆë‹¤.


<br>

### ë°ì´í„° ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬í˜„

###### ê°œë°œ ì¤‘ ë ˆë²¨ì´ ì´ë™í•  ë•Œë§ˆë‹¤ í…ìŠ¤ì²˜ ë¡œë”© ì‹œê°„ì´ ê¸¸ì–´ì ¸ ê²Œì„ í”Œë ˆì´ì˜ ëª°ì…ê°ì„ ì €í•˜ì‹œí‚¤ëŠ” ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì´ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ë°ì´í„° ê´€ë¦¬ ì‹œìŠ¤í…œì„ ì„¤ê³„ ë° êµ¬í˜„í–ˆìŠµë‹ˆë‹¤. í…ìŠ¤ì²˜ì˜ ì´ë¦„ê³¼ íŒŒì¼ ê²½ë¡œë¥¼ All_Sprite.dat íŒŒì¼ì— ì €ì¥í•˜ê³ , ê²Œì„ ì‹œì‘ ì‹œ ëª¨ë“  í…ìŠ¤ì²˜ë¥¼ í•œ ë²ˆì— ì´ˆê¸°í™”í•˜ì—¬ ë¯¸ë¦¬ ë¶ˆëŸ¬ì˜¤ëŠ” ë°©ì‹ìœ¼ë¡œ ìµœì í™”í•˜ì˜€ìŠµë‹ˆë‹¤. ì´í›„ êµìˆ˜ë‹˜ê»˜ì„œ ë©€í‹°ì“°ë ˆë”©ì„ ì‚¬ìš©í•˜ë©´ ì´ëŸ¬í•œ ë¬¸ì œë¥¼ ë”ìš± íš¨ê³¼ì ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆë‹¤ê³  ì¡°ì–¸í•´ ì£¼ì…¨ê³ , ì´ë¥¼ ë°”íƒ•ìœ¼ë¡œ í•™ë¶€ ë§ˆì§€ë§‰ í•™ê¸°ì— Parallel Programming ìˆ˜ì—…ì„ ìˆ˜ê°•í•˜ë©° ê´€ë ¨ ì§€ì‹ì„ ë³´ì¶©í–ˆìŠµë‹ˆë‹¤.

<details>
<summary>Data.cpp</summary>
<div markdown="1">

```c++
Data::Data()
{
    mTextureFileName = "All_Sprite.dat";
    mLogoFileName    = "All_Logos.dat";
    mTextureEnum     = 0;
    mIsDataLoadDone  = false;
}

Data::~Data()
{
    for (auto iterator : mAllTexture)
    {
        delete iterator.second;
    }
    workerThread[0].join();
    mAllTexture.clear();
}

void Data::Initialize_Logos()
{
    std::ifstream sprite_dat(mLogoFileName.c_str());
    std::string   line;
    if (sprite_dat.is_open())
    {
        while (std::getline(sprite_dat, line))
        {
            size_t index = line.find(delimiter);
            // std::string sprite_name = line.substr(0, index);
            eTexture sprite_name = static_cast<eTexture>(mTextureEnum);

            std::string sprite_path = line.substr(index + 1, -1);
            Texture *   texture     = new Texture;
            texture->Initialize(sprite_path.c_str());

            mAllTexture.insert(std::make_pair(sprite_name, texture));
            ++mTextureEnum;
        }
    }
    sprite_dat.close();
}

void Data::Initialize_Texture()
{
    std::ifstream sprite_dat(mTextureFileName.c_str());
    std::string   line;
    if (sprite_dat.is_open())
    {
        while (std::getline(sprite_dat, line))
        {
            size_t index = line.find(delimiter);
            // std::string sprite_name = line.substr(0, index);
            eTexture sprite_name = static_cast<eTexture>(mTextureEnum);

            std::string sprite_path = line.substr(index + 1, -1);
            mLoadQueue.push({sprite_name, sprite_path});
            // Texture *   texture     = new Texture;
            // texture->Initialize(sprite_path.c_str());

            // mAllTexture.insert(std::make_pair(sprite_name, texture));
            ++mTextureEnum;
        }
    }
    sprite_dat.close();

    workerThread.push_back(std::thread{&Data::LoaderThread, this});
}

void Data::UpdateTextureLoad()
{
    if (!mTextureQueue.empty())
    {
        eTexture textureEnum = mTextureQueue.front().first;
        Texture *texture     = mTextureQueue.front().second;

        texture->InitializeWithData();
        mAllTexture.insert(std::make_pair(textureEnum, texture));
        mTextureQueue.pop();
    }
    else if (mTextureQueue.empty() && mLoadQueue.empty())
    {
        mIsDataLoadDone = true;
#ifdef _DEBUG
        IMGUI->Initialize();
#endif
    }
}

void Data::LoaderThread()
{
    while (!mIsDataLoadDone)
    {
        if (!mLoadQueue.empty())
        {
            eTexture    textureEnum = mLoadQueue.front().first;
            std::string texturePath = mLoadQueue.front().second;

            Texture *texture = new Texture;
            texture->LoadPixelData(texturePath);

            mLoadQueue.pop();
            mTextureQueue.push({textureEnum, texture});
        }
    }
}

std::map<eTexture, Texture *> Data::GetAllTexture()
{
    return mAllTexture;
}

Texture *Data::FindTextureWithEnum(eTexture texture)
{
    return mAllTexture[texture];
}

bool Data::IsDataLoadDone() const
{
    return mIsDataLoadDone;
}

int Data::GetLoadingProcess()
{
    return (100 * mAllTexture.size()) / static_cast<int>(eTexture::PARTICLE);
}
```
</div>
</details> 